#  EMD的变体VMD(变分模态分解)
##  概念：
- 将信号分解问题，转换为变分问题。
- 将原始信号代入变分优化框架迭代获得多个代表原始信号不同振动模式的模态分量和残差信号：
- 可将获得的模态分量用于高频降低噪音，再重构信号；

> 补充：变分问题就是在给定的约束条件下，寻找某一个函数，该函数能使某个与之相关的泛函(函数的函数)取得极值；
## 运算框架：
### 1. 变分参数初始化：
- 分解层数K：模态分量的个数：
- 惩罚因子α：用于在优化迭代中调整反馈IMF(模态分量)的带宽和信号的重构精度；
- 中心频率$w_k$:每个模态分量的的中心频率(随机初始化)；0<k<K+1，k为整数;
### 2. 变分优化框架：
a. 对原始信号，按中心频率，带宽(第一次用零点法获得，之后直接用希尔伯特变换获得解调信号的梯度平方的L2范数来间接估计),构成的窗口进行带通滤波获得K个模态分量$u_k(t)$;

b. 该变分问题的目标是找到能使各模态的带宽之和最小的模态分量组；基础泛函为各模态的带宽之和，但为了提高降噪效率，偏向小带宽，在基础泛函上添加一个L2正则化约束的惩罚项($\text{Regularization Term} = \lambda \int_t \left( \frac{d}{dt} u_k(t) \right)^2  dt$ , $ \lambda$是正则化参数)；将完整的泛函代入交替方向乘法ADMM进行迭代优化，至收敛条件，获得优化后的模态分量和中心频率；

完整泛函公式如下：

$$ 
min_{u_k(t),w_k} {\sum_{k=1}^{K} [\lambda \int_t \left( \frac{d}{dt} u_k(t) \right)^2 dt + || \partial_t[(\delta(t) + \frac{j}{\pi t})* u_k(t)]e^{-j\omega_k t}||_2^2}]
$$

- L2正则化约束的惩罚项为$ \lambda \int_t \left( \frac{d}{dt} u_k(t) \right)^2 dt $ ；
- $ \delta(t)$为狄拉克函数（冲激函数）,$\frac{j}{\pi t}$为是与 δ(t) 相关的复数项；
- $(\delta(t) + \frac{j}{\pi t})* u_k(t)$是对$u_k(t)$的希伯尔特变换，*为卷积操作 ；
- $\partial_t$为表示对时间 t 的偏导数，$e^{-j\omega_k t}$是复指数函数，表示频率调制;

单看一个模态的带宽估计公式并进一步展开：

$$
 \lambda \int_t \left( \frac{d}{dt} u_k(t) \right)^2 dt +  |\dot{u}_k(t) e^{-j\omega_k t} + \frac{j}{\pi} \text{P.V.} \int _{- \infty}^{\infty} \frac{u_k(\tau)}{(t - \tau)^2 }e^{-j\omega_k t} d\tau |^2
$$

- PV为柯西主值；
- $\dot{u}_k(t)$为对时间的导数：
- 优化变量为$u_k(t) \, w_k$;

## 补充知识点：
### 1. 带宽：
一个时间向量的最大频率与最小频率的差值：
### 2. 零点法：
- 在短时傅里叶变换FFT获得的频谱上，看中心频率离两边谁更近，用更近的做半带宽；
- 再用半带宽以中心频率为轴，获取左右半带宽的频谱片段；
- 用所获的频谱片段再用逆傅里叶变换获得一维幅值序列(模态分量)；
### 3. 带通滤波：
- 按照已有的中心频率和带宽对于原始信号的频谱进行窗口提取，获得频谱片段；
- 用逆傅里叶变换处理频谱片段获得一维幅值序列(模态分量)；
### 4. 交替方向乘法ADMM(范式)：
#### 优化问题

考虑以下形式的优化问题：

$$\min_{x, z} f(x) + g(z) \quad \text{s.t.} \quad Ax + Bz = c$$

其中，$x$ 和 $z$ 是优化变量，$f(x)$ 和 $g(z)$ 是凸函数，$A, B, c$ 是已知的系数矩阵和向量。这个问题可以看作是VMD中模态函数更新和约束条件满足的一个抽象表示。

#### ADMM算法实现

为了求解上述问题，ADMM算法首先构造增广拉格朗日函数：

$$L_\rho(x, z, y) = f(x) + g(z) + y^T(Ax + Bz - c) + \frac{\rho}{2}\|Ax + Bz - c\|^2$$

其中，$y$ 是拉格朗日乘子，$\rho > 0$ 是惩罚参数。（VMD使用的是惩罚因子α）

然后，ADMM算法通过以下迭代步骤来更新变量和乘子，直到满足收敛条件：

1. **更新$x$**：

   $$x^{k+1} = \arg\min_x L_\rho(x, z^k, y^k)$$

   这通常涉及到求解一个关于$x$的优化问题，该问题只包含与$x$相关的项和约束。

2. **更新$z$**：

   $$z^{k+1} = \arg\min_z L_\rho(x^{k+1}, z, y^k)$$

   类似地，这涉及到求解一个关于$z$的优化问题。

3. **更新$y$**（拉格朗日乘子）：

   $$y^{k+1} = y^k + \rho(Ax^{k+1} + Bz^{k+1} - c)$$

   这一步用于更新拉格朗日乘子，以强化约束条件的满足。

#### 收敛条件

ADMM算法的收敛条件通常基于原始残差和对偶残差的大小。在实际应用中，可以设置一个小的正数$\epsilon$作为阈值，当以下两个条件同时满足时认为算法已经收敛：

$$\|Ax^{k+1} + Bz^{k+1} - c\| \leq \epsilon$$

$$\|y^{k+1} - y^k\| \leq \epsilon$$

或者，可以使用更复杂的收敛准则，如原始残差和对偶残差之间的相对变化量


